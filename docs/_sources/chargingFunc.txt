writing your own charging function
==================================

This section should provide the basics for someone interested in creating new charging algorithms. 

The code you may write should live in the controlled.py module inside the "charging" package.
Before launching a simulation, you may tell V2G-Sim to use your charging function at any location as follow:

.. code-block:: python
	
	for location in locationList:
		location.chargingInfra.chargingFunc = 'charging.controlled.nameOfMyFunction(vehicle, activity, lastIteration, option)'

Let's look at the very basic of all charging functions, the uncontrolled case. This function is named "consumption" in the uncontrolled.py module.

.. code-block:: python

	def consumption(vehicle, activity, lastIteration, option=None):

Parameters:
	* a vehicle instance to make sure that the SOC and the power constraints are respected.
	* an activity so that information on duration and location can be accessed. 
	* a parameter "lastIteration" false for any iteration which is not the last one, and true for the last iteration so only then the data is saved. 
	* a parameter "option" that allows you to pass any sort of supplementary data you might need (price signal...).

The first step is to find the number of intervals that the car will be parked (dictated by vehicle.outputInterval).

.. code-block:: python
	
	def consumption(vehicle, activity, lastIteration, option=None):
		# Find the parked duration
		hourlySteps = 3600/vehicle.outputInterval
		nbInterval = int(driving.end*hourlySteps)-int(driving.start*hourlySteps)


The next step is to iterate through all the intervals of the charging session and decide the power rate to apply.

.. code-block:: python
	
	def consumption(vehicle, activity, lastIteration, option=None):
		# Find the parked duration
		hourlySteps = 3600/vehicle.outputInterval
		nbInterval = int(driving.end*hourlySteps)-int(driving.start*hourlySteps)

		for i in range(0, nbInterval):
			if vehicle.SOC[-1] < vehicle.carModel.SOCMax and parked.pluggedIn is True:
				# Do something
			else:
				# Don't charge

In the end the charging function must at least update vehicle.SOC and parked.powerDemand. You should update vehicle.SOC at every iteration (even if lastIteration is false), however, parked.powerDemand will only be saved at the last iteration (lastIteration is true).

.. code-block:: python
	
	def consumption(vehicle, activity, lastIteration, option=None):
		# Find the parked duration
		hourlySteps = 3600/vehicle.outputInterval
		nbInterval = int(driving.end*hourlySteps)-int(driving.start*hourlySteps)

		for i in range(0, nbInterval):
			if vehicle.SOC[-1] < vehicle.carModel.SOCMax and parked.pluggedIn is True:
				# Check if the vehicle can handle the charger power rate
				if vehicle.carModel.powerRateMax > parked.location.chargingInfra.powerRateMax:
					powerRate = parked.location.chargingInfra.powerRateMax
				else:
					powerRate = vehicle.carModel.powerRateMax
				
				# Set the power demand to be the charger station power
				if lastIteration:
					parked.powerDemand.append(powerRate)
				# Set new SOC to be (SOC + powerDemand*outputInterval/totalCap)
				vehicle.SOC.append(vehicle.SOC[-1]+
								   (powerRate*
								   vehicle.outputInterval/
								   (vehicle.carModel.batteryCap*3600))) # batteryCap from Wh to Joules
			else:
				if lastIteration:
					parked.powerDemand.append(0)
				vehicle.SOC.append(vehicle.SOC[-1])

Feel free to create your own now !
